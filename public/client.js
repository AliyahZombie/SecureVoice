// public/client.js

// --- DOM ÂÖÉÁ¥† ---
const loginModal = document.getElementById('login-modal');
const appContainer = document.getElementById('app');
const joinButton = document.getElementById('joinButton');
const usernameInput = document.getElementById('usernameInput'); // Êñ∞Â¢û
const roomNameInput = document.getElementById('roomNameInput');
const statusText = document.getElementById('statusText');

const localAudio = document.getElementById('localAudio');
const remoteAudioContainer = document.getElementById('remote-audio-container');
const roomNameDisplay = document.getElementById('room-name-display');
const myPeerIdDisplay = document.getElementById('my-peer-id-display');
const micToggleButton = document.getElementById('mic-toggle-footer-btn');
const myAvatar = document.querySelector('.my-avatar');
const connectionLatencyDisplay = document.getElementById('connection-latency');
const connectionQualityDisplay = document.getElementById('connection-quality');
const connectionStateDisplay = document.getElementById('connection-state');

const toggleChatButton = document.getElementById('toggle-chat-btn');
const disconnectButton = document.getElementById('disconnect-btn');
const chatArea = document.querySelector('.chat-area');

const chatMessages = document.getElementById('chat-messages');
const chatInput = document.getElementById('chat-input');
const sendButton = document.getElementById('send-button');
const userListSidebar = document.getElementById('user-list-sidebar');

// --- WebRTC & WebSocket ÂÖ®Â±ÄÂèòÈáè ---
let localStream;
let myPeerId;
let socket;
const peerConnections = new Map();
const visualizers = new Map(); // Â≠òÂÇ® visualizer ÂÆû‰æã
const stunServers = {
    iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' }
    ]
};

// --- ‰∏ªÊµÅÁ®ã ---

joinButton.onclick = async () => {
    const username = usernameInput.value.trim(); // Ëé∑ÂèñÁî®Êà∑Âêç
    const roomName = roomNameInput.value.trim();
    if (!username) { // È™åËØÅÁî®Êà∑Âêç
        alert('ËØ∑ËæìÂÖ•ÊÇ®ÁöÑÁî®Êà∑Âêç');
        return;
    }
    if (!roomName) {
        alert('ËØ∑ËæìÂÖ•ÊàøÈó¥Âêç');
        return;
    }

    usernameInput.disabled = true; // Á¶ÅÁî®Áî®Êà∑ÂêçËæìÂÖ•Ê°Ü

    joinButton.disabled = true;
    roomNameInput.disabled = true;
    statusText.textContent = 'Ê≠£Âú®Ëé∑ÂèñÈ∫¶ÂÖãÈ£é...';
    statusText.classList.remove('hidden');

    try {
        const audioConstraints = {
            audio: {
                echoCancellation: true,
                noiseSuppression: true,
                autoGainControl: true
            },
            video: false
        };
        localStream = await navigator.mediaDevices.getUserMedia(audioConstraints);
        localAudio.srcObject = localStream;
        
        // ËÆæÁΩÆÊú¨Âú∞Èü≥È¢ëÂèØËßÜÂåñ
        setupLocalAudioVisualizer();

        statusText.textContent = 'Ê≠£Âú®ËøûÊé•ÊúçÂä°Âô®...';

        const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        socket = new WebSocket(`${wsProtocol}//${window.location.host}/ws`);
        setupWebSocketListeners(roomName, username); // ‰º†ÈÄíÁî®Êà∑Âêç

    } catch (error) {
        console.error('Ëé∑ÂèñÂ™í‰ΩìËÆæÂ§áÂ§±Ë¥•:', error);
        statusText.textContent = 'Êó†Ê≥ïËÆøÈóÆÈ∫¶ÂÖãÈ£é„ÄÇËØ∑Ê£ÄÊü•ÊùÉÈôê„ÄÇ';
        joinButton.disabled = false;
        roomNameInput.disabled = false;
        usernameInput.disabled = false; // ÈáçÊñ∞ÂêØÁî®Áî®Êà∑ÂêçËæìÂÖ•Ê°Ü
    }
};

micToggleButton.onclick = () => {
    if (!localStream) return;
    const audioTrack = localStream.getAudioTracks()[0];
    if (audioTrack) {
        audioTrack.enabled = !audioTrack.enabled;
        micToggleButton.classList.toggle('muted', !audioTrack.enabled);
        micToggleButton.textContent = audioTrack.enabled ? 'üé§' : 'üîá';
    }
};

toggleChatButton.onclick = () => {
    chatArea.classList.toggle('hidden');
};

disconnectButton.onclick = () => {
    // Êñ≠ÂºÄËøûÊé•
    if (socket && socket.readyState === WebSocket.OPEN) {
        socket.close();
    }
    cleanup();
};


// --- WebSocket ‰∫ã‰ª∂Â§ÑÁêÜ ---

function setupWebSocketListeners(roomName, username) { // Êé•Êî∂Áî®Êà∑Âêç
    socket.onopen = () => {
        statusText.textContent = 'Ê≠£Âú®Âä†ÂÖ•ÊàøÈó¥...';
        // Âú®ËøûÊé•ÊâìÂºÄÊó∂ÂèëÈÄÅ join-room Ê∂àÊÅØÔºåÂåÖÂê´Áî®Êà∑Âêç
        socket.send(JSON.stringify({ type: 'join-room', data: { roomName, username } }));
    };

    socket.onmessage = (event) => {
        const message = JSON.parse(event.data);
        const { type, data } = message;

        switch (type) {
            case 'your-id':
                myPeerId = data.peerId;
                // myPeerIdDisplay.textContent = `ID: ${myPeerId.substring(0, 8)}`; // ‰∏çÂÜçÊòæÁ§∫ID
                myPeerIdDisplay.textContent = username; // ÊòæÁ§∫Áî®Êà∑Âêç
                updateStatus(`ÊàêÂäüÂä†ÂÖ•ÊàøÈó¥: ${roomName}`);
                roomNameDisplay.textContent = roomName;
                loginModal.classList.add('hidden');
                appContainer.classList.remove('hidden');
                connectionStateDisplay.textContent = 'Voice Connected';
                connectionStateDisplay.classList.add('connected');

                // Ê®°ÊãüÊõ¥Êñ∞ËøûÊé•Âª∂ËøüÂíåË¥®Èáè
                setInterval(updateConnectionStats, 5000);

                // Â∞ÜËá™Â∑±Ê∑ªÂä†Âà∞‰æßËæπÊ†è
                addSidebarUser(myPeerId, username);

                // ‰∏∫ÊØè‰∏™Â∑≤Â≠òÂú®ÁöÑ peer ÂàõÂª∫ËøûÊé•Âπ∂ÂèëÈÄÅ offer
                if (Array.isArray(data.peers)) { // data.peers Áé∞Âú®ÂåÖÂê´ { peerId, username }
                    data.peers.forEach(peer => {
                        createAndSendOffer(peer.peerId);
                        // Âú®‰æßËæπÊ†èÊ∑ªÂä†Â∑≤Â≠òÂú®ÁöÑÁî®Êà∑
                        addSidebarUser(peer.peerId, peer.username);
                    });
                }
                chatInput.disabled = false;
                sendButton.disabled = false;
                setupChat();
                break;
            case 'new-peer':
                console.log(`Êñ∞ÊàêÂëòÂä†ÂÖ•: ${data.peerId} (${data.username})`);
                addChatMessage('Á≥ªÁªü', `ÊàêÂëò ${data.username} Âä†ÂÖ•‰∫ÜÈ¢ëÈÅì„ÄÇ`);
                // ‰∏ªÂä®ÂêëÊñ∞ÊàêÂëòÂèëËµ∑ËøûÊé•
                createAndSendOffer(data.peerId);
                // Âú®‰æßËæπÊ†èÊ∑ªÂä†Êñ∞Áî®Êà∑
                addSidebarUser(data.peerId, data.username);
                break;
            case 'offer':
                handleOffer(data.sdp, data.senderId, data.senderUsername); // ‰º†ÈÄíÁî®Êà∑Âêç
                break;
            case 'answer':
                handleAnswer(data.sdp, data.senderId);
                break;
            case 'ice-candidate':
                handleIceCandidate(data.candidate, data.senderId);
                break;
            case 'chat-message':
                addChatMessage(data.senderUsername, data.message, false); // ‰ΩøÁî®Áî®Êà∑Âêç
                break;
            case 'peer-disconnected':
                handlePeerDisconnect(data.peerId);
                addChatMessage('Á≥ªÁªü', `ÊàêÂëò ${data.username} Á¶ªÂºÄ‰∫ÜÈ¢ëÈÅì„ÄÇ`); // ‰ΩøÁî®Áî®Êà∑Âêç
                break;
            case 'username-taken': // Êñ∞Â¢ûÔºöÂ§ÑÁêÜÁî®Êà∑ÂêçÈáçÂ§ç
                alert(`Áî®Êà∑Âêç "${data.username}" Â∑≤Ë¢´Âç†Áî®ÔºåËØ∑ÈÄâÊã©ÂÖ∂‰ªñÁî®Êà∑Âêç„ÄÇ`);
                cleanup(); // Ê∏ÖÁêÜÂπ∂ÈáçÊñ∞ÂêØÁî®ËæìÂÖ•
                break;
        }
    };

    socket.onclose = () => {
        alert('‰∏éÊúçÂä°Âô®ÁöÑËøûÊé•Â∑≤Êñ≠ÂºÄÔºåËØ∑Âà∑Êñ∞È°µÈù¢ÈáçËØï„ÄÇ');
        cleanup();
    };
    
    socket.onerror = (error) => {
        console.error("WebSocket Error:", error);
         alert('ËøûÊé•ÂèëÁîüÈîôËØØÔºåËØ∑Âà∑Êñ∞È°µÈù¢ÈáçËØï„ÄÇ');
        cleanup();
    };
}


// --- WebRTC Ê†∏ÂøÉÂáΩÊï∞ ---

function createPeerConnection(peerId) {
    if (peerConnections.has(peerId)) {
        return peerConnections.get(peerId);
    }
    
    const pc = new RTCPeerConnection(stunServers);
    peerConnections.set(peerId, pc);

    localStream.getTracks().forEach(track => {
        pc.addTrack(track, localStream);
    });

    // 2. Â§ÑÁêÜÊî∂Âà∞ÁöÑ ICE Candidate
    pc.onicecandidate = (event) => {
        if (event.candidate) {
            socket.send(JSON.stringify({
                type: 'ice-candidate',
                data: { target: peerId, candidate: event.candidate }
            }));
        }
    };

    pc.ontrack = (event) => {
        addRemoteAudioStream(peerId, event.streams[0]);
    };
    
    pc.onconnectionstatechange = () => {
        console.log(`‰∏é ${peerId} ÁöÑËøûÊé•Áä∂ÊÄÅ: ${pc.connectionState}`);
        if(pc.connectionState === 'disconnected' || pc.connectionState === 'failed' || pc.connectionState === 'closed') {
           handlePeerDisconnect(peerId);
        }
    };
    
    return pc;
}

// ( ‡§¨‡§æ‡§ï‡•Ä ‡§ï‡•á WebRTC functions: createAndSendOffer, handleOffer, etc. ‡§∏‡§Æ‡§æ‡§® ‡§∞‡§π‡§§‡•á ‡§π‡•à‡§Ç )
async function createAndSendOffer(peerId) {
    const pc = createPeerConnection(peerId);
    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    socket.send(JSON.stringify({
        type: 'offer',
        data: { target: peerId, sdp: pc.localDescription }
    }));
}
 
// Â≠òÂÇ® peerId Âà∞ username ÁöÑÊò†Â∞Ñ
const peerIdToUsernameMap = new Map();

async function handleOffer(sdp, senderId, senderUsername) { // Êé•Êî∂Áî®Êà∑Âêç
    peerIdToUsernameMap.set(senderId, senderUsername); // Â≠òÂÇ®Êò†Â∞Ñ
    const pc = createPeerConnection(senderId);
    await pc.setRemoteDescription(new RTCSessionDescription(sdp));
    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);
    socket.send(JSON.stringify({
        type: 'answer',
        data: { target: senderId, sdp: pc.localDescription }
    }));
}

async function handleAnswer(sdp, senderId) {
    const pc = peerConnections.get(senderId);
    if (pc) {
        await pc.setRemoteDescription(new RTCSessionDescription(sdp));
    }
}

async function handleIceCandidate(candidate, senderId) {
    const pc = peerConnections.get(senderId);
    if (pc) {
        try {
            await pc.addIceCandidate(new RTCIceCandidate(candidate));
        } catch(e) {
            console.error("Ê∑ªÂä† ICE candidate Â§±Ë¥•:", e);
        }
    }
}


function handlePeerDisconnect(peerId) {
    const pc = peerConnections.get(peerId);
    if (pc) {
        pc.close();
        peerConnections.delete(peerId);
    }

    const visualizer = visualizers.get(peerId);
    if(visualizer) {
        visualizer.stop();
        visualizers.delete(peerId);
    }

    const audioCard = document.getElementById(`audio-card-${peerId}`);
    if (audioCard) {
        audioCard.remove();
    }

    const sidebarUser = document.getElementById(`sidebar-user-${peerId}`);
    if (sidebarUser) {
        sidebarUser.remove();
    }

    console.log(`‰∏éÊàêÂëò ${peerId} ÁöÑËøûÊé•Â∑≤ÂÖ≥Èó≠`);
}


// --- ËÅäÂ§©ÂäüËÉΩ ---

function setupChat() {
    sendButton.onclick = sendMessage;
    chatInput.onkeydown = (event) => {
        if (event.key === 'Enter' && !event.shiftKey) {
            event.preventDefault();
            sendMessage();
        }
    };
}

function sendMessage() {
    const message = chatInput.value.trim();
    if (message && socket && socket.readyState === WebSocket.OPEN) {
        socket.send(JSON.stringify({
            type: 'chat-message',
            data: { message, senderUsername: myPeerIdDisplay.textContent } // ÂèëÈÄÅÁî®Êà∑Âêç
        }));
        addChatMessage('Êàë', message, true);
        chatInput.value = '';
    }
}

function addChatMessage(sender, message, isMe) {
    const messageElement = document.createElement('div');
    messageElement.className = 'chat-message';
    if(isMe) messageElement.style.color = '#fff';

    const timestamp = document.createElement('span');
    timestamp.className = 'timestamp';
    timestamp.textContent = new Date().toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit'});

    const senderSpan = document.createElement('span');
    senderSpan.className = 'peer-id';
    senderSpan.textContent = sender;
    
    const messageText = document.createElement('span');
    messageText.textContent = message;

    messageElement.appendChild(timestamp);
    messageElement.appendChild(senderSpan);
    messageElement.appendChild(messageText);
    
    chatMessages.appendChild(messageElement);
    chatMessages.scrollTop = chatMessages.scrollHeight;
}


// --- Áä∂ÊÄÅÊõ¥Êñ∞ ---
function updateStatus(message) {
    if (statusText) {
        statusText.textContent = message;
        statusText.classList.remove('hidden');
    } else {
        console.warn("statusText element not found. Cannot update status:", message);
    }
}

// --- UI & ÂèØËßÜÂåñ ---

function setupLocalAudioVisualizer() {
    if(!localStream || !myAvatar) return;
    
    // Êàë‰ª¨‰∏çÈúÄË¶Å‰∏∫Êú¨Âú∞Èü≥È¢ëÁªòÂà∂ canvas, Âè™ÈúÄË¶ÅÈü≥ÈáèÂõûË∞É
    const localVisualizer = createVisualizer(localStream, null, (volume) => {
        // ËÆæÁΩÆ‰∏Ä‰∏™ÈòàÂÄºÊù•Âà§Êñ≠ÊòØÂê¶Âú®ËØ¥ËØù
        if (volume > 5) { // Ëøô‰∏™ÂÄºÂèØËÉΩÈúÄË¶ÅÂæÆË∞É
            myAvatar.classList.add('speaking');
        } else {
            myAvatar.classList.remove('speaking');
        }
    });

    visualizers.set('local', localVisualizer);
}

function addRemoteAudioStream(peerId, stream) {
    // --- 1. Âú®‰∏ªÂÜÖÂÆπÂå∫ÂàõÂª∫Èü≥È¢ëÂç°Áâá (‰øùÊåÅ‰∏çÂèò) ---
    if (!document.getElementById(`audio-card-${peerId}`)) {
        const card = document.createElement('div');
        card.id = `audio-card-${peerId}`;
        card.className = 'audio-card';

        const avatar = document.createElement('div');
        avatar.className = 'avatar';
        
        const audio = document.createElement('audio');
        audio.srcObject = stream;
        audio.autoplay = true;
        audio.playsInline = true;

        const peerInfo = document.createElement('div');
        peerInfo.className = 'peer-info';
        peerInfo.textContent = peerIdToUsernameMap.get(peerId) || `ID: ${peerId.substring(0, 8)}`; // ÊòæÁ§∫Áî®Êà∑Âêç
        
        card.appendChild(avatar);
        card.appendChild(peerInfo);
        card.appendChild(audio);
        remoteAudioContainer.appendChild(card);

        // ‰∏∫ËøúÁ®ãÈü≥È¢ëËÆæÁΩÆÂèØËßÜÂåñ
        const visualizer = createVisualizer(stream, null, (volume) => {
            if (volume > 5) {
                avatar.classList.add('speaking');
                // ÂêåÊ≠•‰æßËæπÊ†èÂ§¥ÂÉè
                document.querySelector(`#sidebar-user-${peerId} .avatar`)?.classList.add('speaking');
            } else {
                avatar.classList.remove('speaking');
                document.querySelector(`#sidebar-user-${peerId} .avatar`)?.classList.remove('speaking');
            }
        });
        visualizers.set(peerId, visualizer);
    }
    // ‰æßËæπÊ†èÁî®Êà∑ÂàóË°®È°πÁöÑÊ∑ªÂä†Áé∞Âú®Áî± `addSidebarUser` ÂáΩÊï∞Â§ÑÁêÜ
}

// Êñ∞Â¢ûÂáΩÊï∞ÔºöÂú®‰æßËæπÊ†èÊ∑ªÂä†Áî®Êà∑
function addSidebarUser(peerId, username) {
    if (!document.getElementById(`sidebar-user-${peerId}`)) {
        const userElement = document.createElement('div');
        userElement.id = `sidebar-user-${peerId}`;
        userElement.className = 'sidebar-user';

        if (peerId === myPeerId) {
            userElement.classList.add('me');
        }

        const avatar = document.createElement('div');
        avatar.className = 'avatar';

        const usernameSpan = document.createElement('span');
        usernameSpan.textContent = username; // ÊòæÁ§∫Áî®Êà∑Âêç

        userElement.appendChild(avatar);
        userElement.appendChild(usernameSpan);
        userListSidebar.appendChild(userElement);
    }
}

function cleanup() {
    // ÂÅúÊ≠¢ÊâÄÊúâÂèØËßÜÂåñ
    visualizers.forEach(v => v.stop());
    visualizers.clear();

    peerConnections.forEach(pc => pc.close());
    peerConnections.clear();
    
    remoteAudioContainer.innerHTML = '';
    if(userListSidebar) userListSidebar.innerHTML = '';
    
    localStream?.getTracks().forEach(track => track.stop());
    localAudio.srcObject = null;
    
    appContainer.classList.add('hidden');
    loginModal.classList.remove('hidden');

    joinButton.disabled = false;
    roomNameInput.disabled = false;
    usernameInput.disabled = false; // ÈáçÊñ∞ÂêØÁî®Áî®Êà∑ÂêçËæìÂÖ•Ê°Ü
    roomNameInput.value = '';
    usernameInput.value = ''; // Ê∏ÖÁ©∫Áî®Êà∑ÂêçËæìÂÖ•Ê°Ü
    statusText.textContent = '';
    statusText.classList.add('hidden');

    myPeerIdDisplay.textContent = 'Êú™ËøûÊé•';
    chatMessages.innerHTML = '';
    chatInput.value = '';
    chatInput.disabled = true;
    sendButton.disabled = true;
    micToggleButton.classList.add('muted');
    peerIdToUsernameMap.clear(); // Ê∏ÖÈô§Êò†Â∞Ñ
    connectionLatencyDisplay.textContent = 'Ping: --ms';
    connectionQualityDisplay.textContent = 'Quality: --';
    connectionStateDisplay.textContent = 'Connecting';
    connectionStateDisplay.classList.remove('connected');
    chatArea.classList.remove('hidden'); // Á°Æ‰øùËÅäÂ§©Âå∫ÂüüÂú®Ê∏ÖÁêÜÂêéÂèØËßÅ
}

async function updateConnectionStats() {
    if (peerConnections.size === 0) {
        connectionLatencyDisplay.textContent = `Ping: --ms`;
        connectionQualityDisplay.textContent = `Quality: --`;
        return;
    }

    let totalRoundTripTime = 0;
    let connectedPeers = 0;

    for (const pc of peerConnections.values()) {
        if (pc.connectionState !== 'connected') continue;

        try {
            const stats = await pc.getStats();
            stats.forEach(report => {
                // ÂØªÊâæÂ∑≤ÊàêÂäüÁöÑ ICE candidate pair
                if (report.type === 'candidate-pair' && report.state === 'succeeded') {
                    // currentRoundTripTime ÊòØÁßíÔºåÈúÄË¶Å‰πò‰ª• 1000 ÂæóÂà∞ÊØ´Áßí
                    if (report.currentRoundTripTime) {
                        totalRoundTripTime += report.currentRoundTripTime * 1000;
                        connectedPeers++;
                    }
                }
            });
        } catch (error) {
            console.error("Ëé∑Âèñ WebRTC ÁªüËÆ°‰ø°ÊÅØÂ§±Ë¥•:", error);
        }
    }

    if (connectedPeers > 0) {
        const averageLatency = Math.round(totalRoundTripTime / connectedPeers);
        let quality = 'ËâØÂ•Ω';
        if (averageLatency > 150) {
            quality = '‰∏ÄËà¨';
        }
        if (averageLatency > 250) {
            quality = 'Â∑Æ';
        }
        connectionLatencyDisplay.textContent = `Ping: ${averageLatency}ms`;
        connectionQualityDisplay.textContent = `Quality: ${quality}`;
    } else {
        connectionLatencyDisplay.textContent = `Ping: --ms`;
        connectionQualityDisplay.textContent = `Quality: --`;
    }
}
